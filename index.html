<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Code Animator</title>
  <style>
    @font-face {
      font-family: 'PP Right Serif Mono';
      src: url('./fonts/PPRightSerifMono-Regular.woff2') format('woff2'),
           url('./fonts/PPRightSerifMono-Regular.woff') format('woff');
      font-weight: normal;
      font-style: normal;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    :root {
      --bg: #0a0a0f;
      --panel: #12121a;
      --border: #2a2a3a;
      --text: #e0e0e0;
      --accent: #7c3aed;
    }

    body {
      font-family: system-ui, -apple-system, sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      display: flex;
    }

    /* Control Panel */
    .controls {
      width: 320px;
      background: var(--panel);
      border-right: 1px solid var(--border);
      padding: 20px;
      overflow-y: auto;
      height: 100vh;
    }

    .controls h1 {
      font-size: 1.5rem;
      margin-bottom: 20px;
      background: linear-gradient(135deg, #7c3aed, #ec4899);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .control-group {
      margin-bottom: 20px;
    }

    .control-group label {
      display: block;
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: #888;
      margin-bottom: 8px;
    }

    select, input[type="number"], input[type="range"], input[type="text"] {
      width: 100%;
      padding: 10px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text);
      font-size: 14px;
    }

    select:focus, input:focus {
      outline: none;
      border-color: var(--accent);
    }

    textarea {
      width: 100%;
      height: 150px;
      padding: 10px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text);
      font-family: monospace;
      font-size: 12px;
      resize: vertical;
    }

    .btn {
      width: 100%;
      padding: 12px;
      background: var(--accent);
      border: none;
      border-radius: 6px;
      color: white;
      font-weight: 600;
      cursor: pointer;
      margin-top: 10px;
    }

    .btn:hover { opacity: 0.9; }
    .btn.secondary { background: var(--border); }

    .btn-row {
      display: flex;
      gap: 10px;
    }
    .btn-row .btn { flex: 1; }

    .checkbox-group {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .checkbox-group label {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 13px;
      color: var(--text);
      text-transform: none;
      letter-spacing: normal;
      cursor: pointer;
    }

    .range-value {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .range-value span {
      font-size: 12px;
      color: #888;
    }

    /* Preview Area */
    .preview-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }

    .preview-header {
      padding: 15px 20px;
      background: var(--panel);
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .preview-header h2 {
      font-size: 1rem;
      font-weight: 500;
    }

    .preview {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 40px;
      overflow: auto;
    }

    .code-display {
      padding: 30px;
      border-radius: 12px;
      min-width: 600px;
      max-width: 900px;
      position: relative;
      box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
    }

    .code-display pre {
      margin: 0;
      white-space: pre-wrap;
      word-break: break-all;
      line-height: 1.6;
      font-family: inherit;
    }

    .code-display code {
      font-family: inherit;
    }

    /* Window Controls */
    .window-controls {
      position: absolute;
      top: 15px;
      left: 15px;
      display: flex;
      gap: 8px;
    }

    .window-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
    }

    .window-dot.red { background: #ff5f56; }
    .window-dot.yellow { background: #ffbd2e; }
    .window-dot.green { background: #27ca40; }

    /* Cursor Styles */
    .cursor {
      display: inline-block;
      animation: blink 1s step-end infinite;
    }

    .cursor-block {
      background: currentColor;
      width: 0.6em;
      height: 1.2em;
      vertical-align: text-bottom;
    }

    .cursor-outline {
      border: 2px solid currentColor;
      width: 0.6em;
      height: 1.2em;
      vertical-align: text-bottom;
    }

    .cursor-outline-x {
      border: 2px solid currentColor;
      width: 0.6em;
      height: 1.2em;
      vertical-align: text-bottom;
      position: relative;
    }

    .cursor-outline-x::before,
    .cursor-outline-x::after {
      content: '';
      position: absolute;
      width: 2px;
      height: 100%;
      background: currentColor;
      top: 0;
      left: 50%;
      transform-origin: center;
    }

    .cursor-outline-x::before { transform: translateX(-50%) rotate(45deg); }
    .cursor-outline-x::after { transform: translateX(-50%) rotate(-45deg); }

    .cursor-ibeam {
      width: 2px;
      height: 1.2em;
      background: currentColor;
      vertical-align: text-bottom;
    }

    .cursor-underscore {
      width: 0.6em;
      height: 3px;
      background: currentColor;
      vertical-align: baseline;
    }

    .cursor-triangle {
      width: 0;
      height: 0;
      border-left: 6px solid transparent;
      border-right: 6px solid transparent;
      border-bottom: 12px solid currentColor;
      vertical-align: text-bottom;
    }

    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0; }
    }

    /* Themes */
    .theme-midnight {
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      color: #a5b4fc;
    }

    .theme-dracula {
      background: #282a36;
      color: #f8f8f2;
    }

    .theme-monokai {
      background: #272822;
      color: #f8f8f2;
    }

    .theme-nord {
      background: #2e3440;
      color: #eceff4;
    }

    .theme-synthwave {
      background: linear-gradient(135deg, #2b1055 0%, #190a28 100%);
      color: #ff7edb;
    }

    .theme-matrix {
      background: #0d0d0d;
      color: #00ff00;
    }

    .theme-paper {
      background: #faf8f5;
      color: #2d2d2d;
    }

    .theme-solarized {
      background: #002b36;
      color: #839496;
    }

    .theme-cyberpunk {
      background: linear-gradient(135deg, #0f0c29 0%, #302b63 50%, #24243e 100%);
      color: #0ff;
    }

    .theme-sunset {
      background: linear-gradient(135deg, #2d1f3d 0%, #1a1423 100%);
      color: #ffa07a;
    }

    /* Syntax Highlighting */
    .syntax-keyword { color: #c792ea; }
    .syntax-string { color: #c3e88d; }
    .syntax-number { color: #f78c6c; }
    .syntax-comment { color: #676e95; font-style: italic; }
    .syntax-function { color: #82aaff; }
    .syntax-operator { color: #89ddff; }
    .syntax-variable { color: #f07178; }
    .syntax-type { color: #ffcb6b; }
    .syntax-property { color: #80cbc4; }

    /* Animated syntax highlighting */
    .syntax-glow .syntax-keyword { text-shadow: 0 0 10px currentColor; }
    .syntax-glow .syntax-string { text-shadow: 0 0 10px currentColor; }
    .syntax-glow .syntax-function { text-shadow: 0 0 10px currentColor; }

    .syntax-rainbow .syntax-keyword { animation: rainbow 3s linear infinite; }
    .syntax-rainbow .syntax-string { animation: rainbow 3s linear infinite 0.5s; }
    .syntax-rainbow .syntax-function { animation: rainbow 3s linear infinite 1s; }

    @keyframes rainbow {
      0% { color: #ff6b6b; }
      20% { color: #feca57; }
      40% { color: #48dbfb; }
      60% { color: #ff9ff3; }
      80% { color: #54a0ff; }
      100% { color: #ff6b6b; }
    }

    .syntax-pulse span[class^="syntax-"] {
      animation: pulse 2s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    /* Line numbers */
    .line-numbers {
      counter-reset: line;
    }

    .line-numbers .line::before {
      counter-increment: line;
      content: counter(line);
      display: inline-block;
      width: 2.5em;
      margin-right: 1em;
      text-align: right;
      color: #555;
      user-select: none;
    }

    /* Character animations */
    .char-wave .char {
      display: inline-block;
      animation: wave 0.5s ease-in-out;
    }

    @keyframes wave {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-5px); }
    }

    .char-fade .char {
      animation: fadeIn 0.3s ease-out;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    .char-scale .char {
      display: inline-block;
      animation: scaleIn 0.2s ease-out;
    }

    @keyframes scaleIn {
      from { transform: scale(0); }
      to { transform: scale(1); }
    }

    .char-slide .char {
      display: inline-block;
      animation: slideIn 0.2s ease-out;
    }

    @keyframes slideIn {
      from { transform: translateX(-10px); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }

    .char-glitch .char {
      animation: glitch 0.3s steps(2);
    }

    @keyframes glitch {
      0% { transform: translate(-2px, 2px); filter: hue-rotate(90deg); }
      25% { transform: translate(2px, -2px); filter: hue-rotate(180deg); }
      50% { transform: translate(-2px, -2px); filter: hue-rotate(270deg); }
      75% { transform: translate(2px, 2px); filter: hue-rotate(360deg); }
      100% { transform: translate(0, 0); filter: hue-rotate(0deg); }
    }

    /* Stats bar */
    .stats {
      font-size: 12px;
      color: #666;
      display: flex;
      gap: 20px;
    }
  </style>
</head>
<body>
  <div class="controls">
    <h1>Code Animator</h1>

    <div class="control-group">
      <label>Code Input</label>
      <textarea id="codeInput">function fibonacci(n) {
  if (n <= 1) return n;

  let prev = 0, curr = 1;

  for (let i = 2; i <= n; i++) {
    const next = prev + curr;
    prev = curr;
    curr = next;
  }

  return curr;
}

// Calculate the 10th Fibonacci number
const result = fibonacci(10);
console.log("Result:", result);</textarea>
    </div>

    <div class="control-group">
      <label>Font Family</label>
      <select id="fontFamily">
        <option value="ui-monospace, 'SF Mono', Menlo, Monaco, monospace">SF Mono / Menlo</option>
        <option value="'PP Right Serif Mono', monospace">PP Right Serif Mono</option>
        <option value="'Courier New', Courier, monospace">Courier New</option>
        <option value="'Fira Code', monospace">Fira Code</option>
        <option value="'JetBrains Mono', monospace">JetBrains Mono</option>
        <option value="'Source Code Pro', monospace">Source Code Pro</option>
        <option value="Consolas, monospace">Consolas</option>
        <option value="'Monaco', monospace">Monaco</option>
        <option value="'IBM Plex Mono', monospace">IBM Plex Mono</option>
        <option value="'Roboto Mono', monospace">Roboto Mono</option>
        <option value="'Anonymous Pro', monospace">Anonymous Pro</option>
      </select>
    </div>

    <div class="control-group">
      <label>Font Size</label>
      <div class="range-value">
        <input type="range" id="fontSize" min="10" max="32" value="16">
        <span id="fontSizeValue">16px</span>
      </div>
    </div>

    <div class="control-group">
      <label>Theme</label>
      <select id="theme">
        <option value="midnight">Midnight</option>
        <option value="dracula">Dracula</option>
        <option value="monokai">Monokai</option>
        <option value="nord">Nord</option>
        <option value="synthwave">Synthwave</option>
        <option value="matrix">Matrix</option>
        <option value="paper">Paper (Light)</option>
        <option value="solarized">Solarized Dark</option>
        <option value="cyberpunk">Cyberpunk</option>
        <option value="sunset">Sunset</option>
      </select>
    </div>

    <div class="control-group">
      <label>Cursor Style</label>
      <select id="cursorStyle">
        <option value="block">Block (Filled)</option>
        <option value="outline">Block (Outline)</option>
        <option value="outline-x">Block (X)</option>
        <option value="ibeam">I-Beam</option>
        <option value="underscore">Underscore</option>
        <option value="triangle">Triangle</option>
        <option value="none">None</option>
      </select>
    </div>

    <div class="control-group">
      <label>Typing Effect</label>
      <select id="typingEffect">
        <option value="normal">Normal (Left to Right)</option>
        <option value="natural">Natural (Human-like)</option>
        <option value="word">Word by Word</option>
        <option value="token">Whole Words/Tokens</option>
        <option value="line">Line by Line</option>
        <option value="random">Random Characters</option>
        <option value="reverse">Reverse (Right to Left)</option>
        <option value="middle-out">Middle Out</option>
        <option value="ends-in">Ends to Middle</option>
        <option value="typewriter">Typewriter (with mistakes)</option>
      </select>
    </div>

    <div class="control-group">
      <label>Character Animation</label>
      <select id="charAnimation">
        <option value="none">None</option>
        <option value="wave">Wave</option>
        <option value="fade">Fade In</option>
        <option value="scale">Scale In</option>
        <option value="slide">Slide In</option>
        <option value="glitch">Glitch</option>
      </select>
    </div>

    <div class="control-group">
      <label>Syntax Highlighting</label>
      <select id="syntaxStyle">
        <option value="none">None</option>
        <option value="static">Static</option>
        <option value="glow">Glow Effect</option>
        <option value="rainbow">Rainbow Cycle</option>
        <option value="pulse">Pulse</option>
      </select>
    </div>

    <div class="control-group">
      <label>Speed (ms per tick)</label>
      <div class="range-value">
        <input type="range" id="speed" min="10" max="500" value="50">
        <span id="speedValue">50ms</span>
      </div>
    </div>

    <div class="control-group">
      <label>Characters per Tick</label>
      <div class="range-value">
        <input type="range" id="charsPerTick" min="1" max="10" value="1">
        <span id="charsPerTickValue">1</span>
      </div>
    </div>

    <div class="control-group">
      <label>Options</label>
      <div class="checkbox-group">
        <label><input type="checkbox" id="showLineNumbers"> Line Numbers</label>
        <label><input type="checkbox" id="showWindowControls" checked> Window Dots</label>
        <label><input type="checkbox" id="cursorBlink" checked> Cursor Blink</label>
      </div>
    </div>

    <div class="btn-row">
      <button class="btn" id="startBtn">Play</button>
      <button class="btn secondary" id="resetBtn">Reset</button>
    </div>

    <div class="btn-row">
      <button class="btn secondary" id="pauseBtn">Pause</button>
      <button class="btn secondary" id="instantBtn">Instant</button>
    </div>
  </div>

  <div class="preview-container">
    <div class="preview-header">
      <h2>Preview</h2>
      <div class="stats">
        <span id="charCount">0 / 0 chars</span>
        <span id="lineCount">0 lines</span>
      </div>
    </div>
    <div class="preview">
      <div class="code-display theme-midnight" id="codeDisplay">
        <div class="window-controls" id="windowControls">
          <div class="window-dot red"></div>
          <div class="window-dot yellow"></div>
          <div class="window-dot green"></div>
        </div>
        <pre id="codeOutput"><code></code></pre>
      </div>
    </div>
  </div>

  <script>
    // State
    let animationId = null;
    let isPaused = false;
    let currentIndex = 0;
    let displayedText = '';
    let codeToType = '';
    let randomOrder = [];

    // Elements
    const codeInput = document.getElementById('codeInput');
    const codeOutput = document.getElementById('codeOutput').querySelector('code');
    const codeDisplay = document.getElementById('codeDisplay');
    const windowControls = document.getElementById('windowControls');

    // Controls
    const fontFamily = document.getElementById('fontFamily');
    const fontSize = document.getElementById('fontSize');
    const theme = document.getElementById('theme');
    const cursorStyle = document.getElementById('cursorStyle');
    const typingEffect = document.getElementById('typingEffect');
    const charAnimation = document.getElementById('charAnimation');
    const syntaxStyle = document.getElementById('syntaxStyle');
    const speed = document.getElementById('speed');
    const charsPerTick = document.getElementById('charsPerTick');
    const showLineNumbers = document.getElementById('showLineNumbers');
    const showWindowControls = document.getElementById('showWindowControls');
    const cursorBlink = document.getElementById('cursorBlink');

    // Buttons
    const startBtn = document.getElementById('startBtn');
    const resetBtn = document.getElementById('resetBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const instantBtn = document.getElementById('instantBtn');

    // Stats
    const charCount = document.getElementById('charCount');
    const lineCount = document.getElementById('lineCount');

    // Tokenizer-based syntax highlighting
    function highlightSyntax(code) {
      const tokens = [];
      let i = 0;

      while (i < code.length) {
        // Single-line comment
        if (code[i] === '/' && code[i + 1] === '/') {
          let end = i;
          while (end < code.length && code[end] !== '\n') end++;
          tokens.push({ type: 'comment', value: code.slice(i, end) });
          i = end;
          continue;
        }

        // Multi-line comment
        if (code[i] === '/' && code[i + 1] === '*') {
          let end = i + 2;
          while (end < code.length && !(code[end] === '*' && code[end + 1] === '/')) end++;
          end += 2;
          tokens.push({ type: 'comment', value: code.slice(i, end) });
          i = end;
          continue;
        }

        // String
        if (code[i] === '"' || code[i] === "'" || code[i] === '`') {
          const quote = code[i];
          let end = i + 1;
          while (end < code.length && code[end] !== quote) {
            if (code[end] === '\\') end++;
            end++;
          }
          end++;
          tokens.push({ type: 'string', value: code.slice(i, end) });
          i = end;
          continue;
        }

        // Number
        if (/[0-9]/.test(code[i]) || (code[i] === '.' && /[0-9]/.test(code[i + 1]))) {
          let end = i;
          while (end < code.length && /[0-9.xXa-fA-F]/.test(code[end])) end++;
          tokens.push({ type: 'number', value: code.slice(i, end) });
          i = end;
          continue;
        }

        // Identifier or keyword
        if (/[a-zA-Z_$]/.test(code[i])) {
          let end = i;
          while (end < code.length && /[a-zA-Z0-9_$]/.test(code[end])) end++;
          const word = code.slice(i, end);
          const keywords = ['function', 'const', 'let', 'var', 'if', 'else', 'for', 'while', 'return', 'class', 'import', 'export', 'from', 'async', 'await', 'try', 'catch', 'new', 'this', 'typeof', 'instanceof', 'true', 'false', 'null', 'undefined'];

          // Check if it's a function call
          let nextNonSpace = end;
          while (nextNonSpace < code.length && code[nextNonSpace] === ' ') nextNonSpace++;

          if (keywords.includes(word)) {
            tokens.push({ type: 'keyword', value: word });
          } else if (code[nextNonSpace] === '(') {
            tokens.push({ type: 'function', value: word });
          } else {
            tokens.push({ type: 'identifier', value: word });
          }
          i = end;
          continue;
        }

        // Default: single character
        tokens.push({ type: 'plain', value: code[i] });
        i++;
      }

      // Convert tokens to HTML
      return tokens.map(token => {
        const escaped = token.value
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;');

        switch (token.type) {
          case 'comment': return `<span class="syntax-comment">${escaped}</span>`;
          case 'string': return `<span class="syntax-string">${escaped}</span>`;
          case 'number': return `<span class="syntax-number">${escaped}</span>`;
          case 'keyword': return `<span class="syntax-keyword">${escaped}</span>`;
          case 'function': return `<span class="syntax-function">${escaped}</span>`;
          default: return escaped;
        }
      }).join('');
    }

    // Wrap characters for animation
    function wrapCharsForAnimation(text, animation) {
      if (animation === 'none') return text;
      return text.replace(/(<[^>]+>)|(.)/g, (match, tag, char) => {
        if (tag) return tag;
        if (char === '\n') return char;
        return `<span class="char">${char}</span>`;
      });
    }

    // Create cursor element
    function createCursor() {
      const style = cursorStyle.value;
      if (style === 'none') return '';

      const blinkClass = cursorBlink.checked ? '' : 'style="animation: none;"';
      return `<span class="cursor cursor-${style}" ${blinkClass}></span>`;
    }

    // Format with line numbers
    function formatWithLineNumbers(text) {
      if (!showLineNumbers.checked) return text;

      const lines = text.split('\n');
      return lines.map(line => `<span class="line">${line}</span>`).join('\n');
    }

    // Update display
    function updateDisplay(text, showCursor = true) {
      let output = text;

      if (syntaxStyle.value !== 'none') {
        output = highlightSyntax(output);
      }

      if (charAnimation.value !== 'none') {
        output = wrapCharsForAnimation(output, charAnimation.value);
      }

      output = formatWithLineNumbers(output);

      if (showCursor) {
        output += createCursor();
      }

      codeOutput.innerHTML = output;

      // Update stats
      charCount.textContent = `${text.length} / ${codeToType.length} chars`;
      lineCount.textContent = `${(text.match(/\n/g) || []).length + 1} lines`;
    }

    // Generate random order for random typing effect
    function generateRandomOrder(length) {
      const indices = Array.from({ length }, (_, i) => i);
      for (let i = indices.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [indices[i], indices[j]] = [indices[j], indices[i]];
      }
      return indices;
    }

    // Natural typing state
    let naturalNextDelay = null;

    // Get next characters based on typing effect
    function getNextChars() {
      const effect = typingEffect.value;
      const count = parseInt(charsPerTick.value);

      switch (effect) {
        case 'normal':
          return codeToType.substring(currentIndex, currentIndex + count);

        case 'natural': {
          // Human-like typing with variable speeds and pauses
          const char = codeToType[currentIndex];
          const nextChar = codeToType[currentIndex + 1];

          // Determine how many characters to type this tick (1-4, weighted toward 1-2)
          let numChars;
          const rand = Math.random();
          if (rand < 0.5) numChars = 1;
          else if (rand < 0.8) numChars = 2;
          else if (rand < 0.95) numChars = 3;
          else numChars = 4;

          // Determine delay for next tick
          const baseSpeed = parseInt(speed.value);

          // Add variation to base speed (0.5x to 1.5x)
          let nextDelay = baseSpeed * (0.5 + Math.random());

          // Longer pause after punctuation
          if (/[.!?;:]/.test(char)) {
            nextDelay = baseSpeed * (2 + Math.random() * 2);
          }
          // Medium pause after comma
          else if (char === ',') {
            nextDelay = baseSpeed * (1.2 + Math.random());
          }
          // Longer pause at end of line
          else if (char === '\n') {
            nextDelay = baseSpeed * (1.5 + Math.random() * 2);
          }
          // Occasional "thinking" pause
          else if (Math.random() < 0.03) {
            nextDelay = baseSpeed * (3 + Math.random() * 3);
          }
          // Occasional burst of speed
          else if (Math.random() < 0.1) {
            nextDelay = baseSpeed * 0.3;
            numChars = Math.min(numChars + 2, 5);
          }

          naturalNextDelay = Math.round(nextDelay);
          return codeToType.substring(currentIndex, currentIndex + numChars);
        }

        case 'word': {
          let endIndex = currentIndex;
          let wordCount = 0;
          while (endIndex < codeToType.length && wordCount < count) {
            if (/\s/.test(codeToType[endIndex])) wordCount++;
            endIndex++;
          }
          return codeToType.substring(currentIndex, endIndex);
        }

        case 'token': {
          // Type entire words/tokens at once
          let endIndex = currentIndex;

          // Skip any leading whitespace first (include it with the token)
          while (endIndex < codeToType.length && /\s/.test(codeToType[endIndex])) {
            endIndex++;
          }

          // Now grab the word/token
          const startChar = codeToType[endIndex];

          if (/[a-zA-Z_$]/.test(startChar)) {
            // Identifier - grab alphanumeric chars
            while (endIndex < codeToType.length && /[a-zA-Z0-9_$]/.test(codeToType[endIndex])) {
              endIndex++;
            }
          } else if (/[0-9]/.test(startChar)) {
            // Number - grab digits and decimal
            while (endIndex < codeToType.length && /[0-9.]/.test(codeToType[endIndex])) {
              endIndex++;
            }
          } else if (/['"`]/.test(startChar)) {
            // String - grab until closing quote
            const quote = startChar;
            endIndex++;
            while (endIndex < codeToType.length && codeToType[endIndex] !== quote) {
              if (codeToType[endIndex] === '\\') endIndex++; // skip escaped char
              endIndex++;
            }
            if (endIndex < codeToType.length) endIndex++; // include closing quote
          } else if (startChar === '/' && codeToType[endIndex + 1] === '/') {
            // Single-line comment - grab until newline
            while (endIndex < codeToType.length && codeToType[endIndex] !== '\n') {
              endIndex++;
            }
          } else if (/[+\-*/%=<>!&|^~?:]/.test(startChar)) {
            // Operators - grab consecutive operator chars
            while (endIndex < codeToType.length && /[+\-*/%=<>!&|^~?:]/.test(codeToType[endIndex])) {
              endIndex++;
            }
          } else {
            // Single character (punctuation, brackets, etc)
            endIndex++;
          }

          // If we didn't move at all, just take one char
          if (endIndex === currentIndex) endIndex++;

          return codeToType.substring(currentIndex, endIndex);
        }

        case 'line': {
          let endIndex = codeToType.indexOf('\n', currentIndex);
          if (endIndex === -1) endIndex = codeToType.length;
          else endIndex++;
          return codeToType.substring(currentIndex, endIndex);
        }

        case 'random': {
          let chars = '';
          for (let i = 0; i < count && currentIndex + i < randomOrder.length; i++) {
            const idx = randomOrder[currentIndex + i];
            chars += codeToType[idx];
          }
          return chars;
        }

        case 'reverse':
          return codeToType.substring(codeToType.length - currentIndex - count, codeToType.length - currentIndex);

        case 'middle-out': {
          const mid = Math.floor(codeToType.length / 2);
          const offset = Math.floor(currentIndex / 2);
          let chars = '';
          if (mid + offset < codeToType.length) chars += codeToType[mid + offset];
          if (mid - offset - 1 >= 0) chars += codeToType[mid - offset - 1];
          return chars;
        }

        case 'ends-in': {
          let chars = '';
          if (currentIndex < codeToType.length) chars += codeToType[currentIndex];
          if (codeToType.length - 1 - currentIndex >= 0 && codeToType.length - 1 - currentIndex !== currentIndex) {
            chars += codeToType[codeToType.length - 1 - currentIndex];
          }
          return chars;
        }

        case 'typewriter': {
          // Occasionally make mistakes and correct them
          if (Math.random() < 0.05 && displayedText.length > 0) {
            displayedText = displayedText.slice(0, -1);
            return '';
          }
          return codeToType.substring(currentIndex, currentIndex + count);
        }

        default:
          return codeToType.substring(currentIndex, currentIndex + count);
      }
    }

    // Build displayed text based on effect
    function buildDisplayedText(chars) {
      const effect = typingEffect.value;

      switch (effect) {
        case 'reverse':
          displayedText = chars + displayedText;
          break;

        case 'random': {
          const charArray = displayedText.split('');
          for (let i = 0; i < chars.length; i++) {
            const idx = randomOrder[currentIndex + i];
            charArray[idx] = codeToType[idx];
          }
          displayedText = charArray.join('');
          break;
        }

        case 'middle-out':
        case 'ends-in': {
          const charArray = displayedText.split('');
          const mid = Math.floor(codeToType.length / 2);
          const offset = Math.floor(currentIndex / 2);

          if (effect === 'middle-out') {
            if (mid + offset < codeToType.length) charArray[mid + offset] = codeToType[mid + offset];
            if (mid - offset - 1 >= 0) charArray[mid - offset - 1] = codeToType[mid - offset - 1];
          } else {
            if (currentIndex < codeToType.length) charArray[currentIndex] = codeToType[currentIndex];
            if (codeToType.length - 1 - currentIndex >= 0) {
              charArray[codeToType.length - 1 - currentIndex] = codeToType[codeToType.length - 1 - currentIndex];
            }
          }
          displayedText = charArray.join('');
          break;
        }

        default:
          displayedText += chars;
      }
    }

    // Animation step
    function animationStep() {
      if (isPaused) return;

      const chars = getNextChars();

      if (chars.length === 0 || currentIndex >= codeToType.length) {
        stopAnimation();
        updateDisplay(codeToType, false);
        return;
      }

      buildDisplayedText(chars);
      currentIndex += chars.length;

      updateDisplay(displayedText, true);

      // Use dynamic delay for natural mode, otherwise use fixed speed
      const delay = (typingEffect.value === 'natural' && naturalNextDelay !== null)
        ? naturalNextDelay
        : parseInt(speed.value);

      animationId = setTimeout(animationStep, delay);
    }

    // Start animation
    function startAnimation() {
      if (animationId) clearTimeout(animationId);

      codeToType = codeInput.value;
      currentIndex = 0;
      isPaused = false;
      naturalNextDelay = null;

      const effect = typingEffect.value;

      if (effect === 'random') {
        randomOrder = generateRandomOrder(codeToType.length);
        displayedText = ' '.repeat(codeToType.length);
      } else if (effect === 'middle-out' || effect === 'ends-in') {
        displayedText = ' '.repeat(codeToType.length);
      } else {
        displayedText = '';
      }

      pauseBtn.textContent = 'Pause';
      animationStep();
    }

    // Stop animation
    function stopAnimation() {
      if (animationId) {
        clearTimeout(animationId);
        animationId = null;
      }
    }

    // Reset
    function reset() {
      stopAnimation();
      currentIndex = 0;
      displayedText = '';
      isPaused = false;
      pauseBtn.textContent = 'Pause';
      updateDisplay('', true);
    }

    // Toggle pause
    function togglePause() {
      isPaused = !isPaused;
      pauseBtn.textContent = isPaused ? 'Resume' : 'Pause';

      if (!isPaused && animationId === null) {
        animationStep();
      }
    }

    // Instant complete
    function instantComplete() {
      stopAnimation();
      codeToType = codeInput.value;
      displayedText = codeToType;
      currentIndex = codeToType.length;
      updateDisplay(displayedText, false);
    }

    // Update styles
    function updateStyles() {
      codeDisplay.style.fontFamily = fontFamily.value;
      codeDisplay.style.fontSize = fontSize.value + 'px';

      // Remove old theme
      codeDisplay.className = 'code-display';
      codeDisplay.classList.add(`theme-${theme.value}`);

      // Add syntax style class
      if (syntaxStyle.value !== 'none' && syntaxStyle.value !== 'static') {
        codeDisplay.classList.add(`syntax-${syntaxStyle.value}`);
      }

      // Add char animation class
      if (charAnimation.value !== 'none') {
        codeDisplay.classList.add(`char-${charAnimation.value}`);
      }

      // Line numbers
      codeOutput.parentElement.classList.toggle('line-numbers', showLineNumbers.checked);

      // Window controls
      windowControls.style.display = showWindowControls.checked ? 'flex' : 'none';
      codeDisplay.style.paddingTop = showWindowControls.checked ? '50px' : '30px';
    }

    // Event listeners
    startBtn.addEventListener('click', startAnimation);
    resetBtn.addEventListener('click', reset);
    pauseBtn.addEventListener('click', togglePause);
    instantBtn.addEventListener('click', instantComplete);

    fontSize.addEventListener('input', () => {
      document.getElementById('fontSizeValue').textContent = fontSize.value + 'px';
      updateStyles();
    });

    speed.addEventListener('input', () => {
      document.getElementById('speedValue').textContent = speed.value + 'ms';
    });

    charsPerTick.addEventListener('input', () => {
      document.getElementById('charsPerTickValue').textContent = charsPerTick.value;
    });

    [fontFamily, theme, cursorStyle, syntaxStyle, charAnimation, showLineNumbers, showWindowControls, cursorBlink].forEach(el => {
      el.addEventListener('change', () => {
        updateStyles();
        if (displayedText) updateDisplay(displayedText, animationId !== null);
      });
    });

    // Initialize
    updateStyles();
    updateDisplay('', true);
  </script>
</body>
</html>
